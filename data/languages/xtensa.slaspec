##########################################################################
#
# Spec by hedgeberg
#
# Attempt at implementing the Xtensa
# 32-bit RISC ISA in SLEIGH.
# Wish me luck.
#
# Disclaimer: If this disclaimer is 
# still present when you obtain this 
# file, assume it is non-functional.
# I'm trying my best here.
#
##########################################################################

@define ENDIANNESS "little"
@define PTRSIZE "4"

define endian=$(ENDIANNESS);
define alignment=1;

define space ram 	type=ram_space 		size=$(PTRSIZE) wordsize=1 default; 
#define space spec_reg 	type=register_space 	size=2;
define space register 	type=register_space 	size=2;

define register offset=0x800 size=4 [PC SP];
define register offset=0x400 size=4 [LBEG LEND LCOUNT SAR BR LITBASE _ _ _ _ _ _ SCOMPARE1 _ _ _];
define register offset=0x500 size=4 [_ _ _ _ _ _ _ _ WindowBase WindowStart _ _ _ _ _ _];
define register offset=0x798 size=4 [PS];

define context PS
	CALLINC = (16, 17)
;

#define bitrange CALLINC=PS[16,2];

define register offset=0x00 size=4 [a0 a1 a2 a3 a4 a5 a6 a7 a8 a9 a10 a11 a12 a13 a14 a15];

define register offset=0x40 size=4 [p0 p1 p2 p3 p4 p5 p6 p7 p8 p9 p10 p11 p12 p13 p14 p15];


define token op24 (24)
	op0 = (0,3)
	op1 = (16, 19)
	op2 = (20, 23)
	reg_r = (12, 15)
	r = (12, 15)
	reg_s = (8, 11)
	s = (8, 11)
	reg_t = (4, 7)
	t = (4, 7)
	rs = (8, 15)
	imm4 = (20, 23)
	imm8 = (16, 23)
	imm12 = (12, 23)
	imm16 = (8, 23)
	call_offset = (6, 23) signed
	simm16 = (8, 23) signed
	val_n = (4, 5)
	val_m = (6, 7)

;

define token op16 (16)
	op0_16 = (0, 3)
	reg_r_16 = (12, 15)
	r_16 = (12, 15)
	reg_s_16 = (8, 11)
	s_16 = (8, 11)
	reg_t_16 = (4, 7)
	t_16 = (4, 7)
	val_i = (7, 7)
	val_z = (6, 6)
	imm7_3_0 = (12, 15)
	imm7_6_4 = (4, 6)
	imm6_3_0 = (12, 15)
	imm6_5_4 = (4, 5)
;

attach variables [reg_r reg_s reg_t reg_r_16 reg_s_16 reg_t_16] [a0 a1 a2 a3 a4 a5 a6 a7 a8 a9 a10 a11 a12 a13 a14 a15];


#####
# Roll macros
#####

macro back_up(sz) {
	local index:2 = 0;
	local a_ptr:2 = &a0;
	local p_ptr:2 = &p0;
	<loop_top>
	*[register]:2 p_ptr = *[register]:2 a_ptr;
	a_ptr = a_ptr + 1;
	p_ptr = p_ptr + 1;
	index = index + 1;
	if (index < sz) goto <loop_top>; 
}

macro roll_forward(sz) {
	local index:2 = 0;
	local endpoint:2 = 16 - sz;
	local src_ptr:2 = &a0 + sz;
	local dst_ptr:2 = &a0;
	<loop_top>
	*[register]:2 dst_ptr = *[register]:2 src_ptr;
	dst_ptr = dst_ptr + 1;
	src_ptr = src_ptr + 1;
	index = index + 1;
	if (index < endpoint) goto <loop_top>;
}

macro restore(sz) {
	local index:2 = 0;
	local a_ptr:2 = &a0;
	local p_ptr:2 = &p0;
	<loop_top>
	*[register]:2 a_ptr = *[register]:2 p_ptr;
	a_ptr = a_ptr + 1;
	p_ptr = p_ptr + 1;
	index = index + 1;
	if (index < sz) goto <loop_top>; 
}

macro roll_backward(sz) {
	local index:2 = 0;
	local endpoint:2 = 16 - sz;
	local src_ptr:2 = &a15 - sz;
	local dst_ptr:2 = &a15;
	<loop_top>
	*[register]:2 dst_ptr = *[register]:2 src_ptr;
	dst_ptr = dst_ptr - 1;
	src_ptr = src_ptr - 1;
	index = index + 1;
	if (index < endpoint) goto <loop_top>;	
}

macro rollback4(){
	a4 = a0;
	a5 = a1;
	a6 = a2;
	a7 = a3;
	a8 = a4;
	a9 = a5;
	a10 = a6;
	a11 = a7;
	a12 = a8;
	a13 = a9;
	a14 = a10;
	a15 = a11;
	a0 = p0;
	a1 = p1;
	a2 = p2;
	a3 = p3;
}

macro rollback8(){
	a8 = a0;
	a9 = a1;
	a10 = a2;
	a11 = a3;
	a12 = a4;
	a13 = a5;
	a14 = a6;
	a15 = a7;
	a0 = p0;
	a1 = p1;
	a2 = p2;
	a3 = p3;
	a4 = p4;
	a5 = p5;
	a6 = p6;
	a7 = p7;
}

macro roolback12(){
	a12 = a0;
	a13 = a1;
	a14 = a2;
	a15 = a3;
	a0 = p0;
	a1 = p1;
	a2 = p2;
	a3 = p3;
	a4 = p4;
	a5 = p5;
	a6 = p6;
	a7 = p7;
	a8 = p8;
	a9 = p9;
	a10 = p10;
	a11 = p11;
}

macro rollfwd4(){
	p0 = a0;
	p1 = a1;
	p2 = a2;
	p3 = a3;
	a0 = a4;
	a1 = a5;
	a2 = a6;
	a3 = a7;
	a4 = a8;
	a5 = a9;
	a6 = a10;
	a7 = a11;
	a8 = a12;
	a9 = a13;
	a10 = a14;
	a11 = a15;
}

macro rollfwd8(){
	p0 = a0;
	p1 = a1;
	p2 = a2;
	p3 = a3;
	p4 = a4;
	p5 = a5; 
	p6 = a6;
	p7 = a7;
	a0 = a8;
	a1 = a9;
	a2 = a10;
	a3 = a11;
	a4 = a12;
	a5 = a13;
	a6 = a14;
	a7 = a15;
}

macro rollfwd12(){
	p0 = a0;
	p1 = a1;
	p2 = a2;
	p3 = a3;
	p4 = a4;
	p5 = a5;
	p6 = a6;
	p7 = a7;
	p8 = a8;
	p9 = a9;
	p10 = a10;
	p11 = a11;
	a0 = a12;
	a1 = a13;
	a2 = a14;
	a3 = a15;
} 

macro instr_top(){}

macro instr_bot(){}

rel16: loc 
is simm16 [loc = ((inst_start+3)&0xfffffffc) + (0xfffc0000|(simm16)<<2);] {
	export *:4 loc;
}

frameSize: loc 
is imm12 [loc=imm12<<3;]{ 
	local tmp:4 = loc; 
	export tmp; 
}

callRel: loc
is call_offset [loc = (inst_start&0xfffffffc) + (call_offset<<2) + 4;]
{
	export *:4 loc;
}


######################################################

:call8 callRel 
is op0=0x5 & val_n=0x2 & callRel {
	rollfwd8();
	call callRel;
	rollback8();
}


:entry reg_s, frameSize
is op0=0x6 & val_n=0x3 & val_m=0x0 & reg_s & frameSize {
	reg_s = reg_s - frameSize;
}


:l32r reg_t, rel16
is op0=0x1 & reg_t & rel16 {
	reg_t = rel16;
}

:mov.n reg_t_16, reg_s_16
is op0_16=0xd & r_16=0x0 & reg_t_16 & reg_s_16 {
	instr_top();
	reg_t_16 = reg_s_16;
	instr_bot();
}



