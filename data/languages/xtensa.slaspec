##########################################################################
#
# Spec by hedgeberg
#
# Attempt at implementing the Xtensa
# 32-bit RISC ISA in SLEIGH.
# Wish me luck.
#
# Disclaimer: If this disclaimer is 
# still present when you obtain this 
# file, assume it is non-functional.
# I'm trying my best here.
#
##########################################################################

@define ENDIANNESS "little"
@define PTRSIZE "4"

define endian=$(ENDIANNESS);
define alignment=1;

define space ram 	type=ram_space 		size=$(PTRSIZE) wordsize=1 default; 
#define space spec_reg 	type=register_space 	size=2;
define space register 	type=register_space 	size=2;

define register offset=0x800 size=4 [PC SP];
define register offset=0x400 size=4 [LBEG LEND LCOUNT SAR BR LITBASE _ _ _ _ _ _ SCOMPARE1 _ _ _];
define register offset=0x500 size=4 [_ _ _ _ _ _ _ _ WindowBase WindowStart _ _ _ _ _ _];
define register offset=0x798 size=4 [PS];

define context PS
	CALLINC = (16, 17)
;

#define bitrange CALLINC=PS[16,2];

define register offset=0x00 size=4 [a0 a1 a2 a3 a4 a5 a6 a7 a8 a9 a10 a11 a12 a13 a14 a15];

define register offset=0x40 size=4 [p0 p1 p2 p3 p4 p5 p6 p7 p8 p9 p10 p11 p12 p13 p14 p15];


define token op24 (24)
	op0 = (0,3)
	op1 = (16, 19)
	op2 = (20, 23)
	reg_r = (12, 15)
	r = (12, 15)
	reg_s = (8, 11)
	s = (8, 11)
	reg_t = (4, 7)
	t = (4, 7)
	sr = (8, 15)
	imm4 = (20, 23)
	imm8 = (16, 23)
	imm12 = (12, 23)
	imm16 = (8, 23)
	imm12_7_0 = (16, 23)
	imm12_11_8 = (8, 11)
	call_offset = (6, 23) signed
	simm16 = (8, 23) signed
	simm12 = (12, 23) signed
	simm8 = (16, 23) signed
	val_n = (4, 5)
	val_m = (6, 7)

;

define token op16 (16)
	op16_whole = (0, 15)
	op0_16 = (0, 3)
	reg_r_16 = (12, 15)
	r_16 = (12, 15)
	reg_s_16 = (8, 11)
	s_16 = (8, 11)
	reg_t_16 = (4, 7)
	t_16 = (4, 7)
	val_i = (7, 7)
	val_z = (6, 6)
	imm7_3_0 = (12, 15)
	imm7_6_4 = (4, 6)
	imm6_3_0 = (12, 15)
	imm6_5_4 = (4, 5)
	imm4_16 = (12, 15)
;

attach variables [reg_r reg_s reg_t reg_r_16 reg_s_16 reg_t_16] [a0 a1 a2 a3 a4 a5 a6 a7 a8 a9 a10 a11 a12 a13 a14 a15];


#####
# Roll macros
#####

macro rollback4(){
	a4 = a0;
	a5 = a1;
	a6 = a2;
	a7 = a3;
	a8 = a4;
	a9 = a5;
	a10 = a6;
	a11 = a7;
	a12 = a8;
	a13 = a9;
	a14 = a10;
	a15 = a11;
	a0 = p0;
	a1 = p1;
	a2 = p2;
	a3 = p3;
}

macro rollback8(){
	a8 = a0;
	a9 = a1;
	a10 = a2;
	a11 = a3;
	a12 = a4;
	a13 = a5;
	a14 = a6;
	a15 = a7;
	a0 = p0;
	a1 = p1;
	a2 = p2;
	a3 = p3;
	a4 = p4;
	a5 = p5;
	a6 = p6;
	a7 = p7;
}

macro roolback12(){
	a12 = a0;
	a13 = a1;
	a14 = a2;
	a15 = a3;
	a0 = p0;
	a1 = p1;
	a2 = p2;
	a3 = p3;
	a4 = p4;
	a5 = p5;
	a6 = p6;
	a7 = p7;
	a8 = p8;
	a9 = p9;
	a10 = p10;
	a11 = p11;
}

macro rollfwd4(){
	p0 = a0;
	p1 = a1;
	p2 = a2;
	p3 = a3;
	a0 = a4;
	a1 = a5;
	a2 = a6;
	a3 = a7;
	a4 = a8;
	a5 = a9;
	a6 = a10;
	a7 = a11;
	a8 = a12;
	a9 = a13;
	a10 = a14;
	a11 = a15;
}

macro rollfwd8(){
	p0 = a0;
	p1 = a1;
	p2 = a2;
	p3 = a3;
	p4 = a4;
	p5 = a5; 
	p6 = a6;
	p7 = a7;
	a0 = a8;
	a1 = a9;
	a2 = a10;
	a3 = a11;
	a4 = a12;
	a5 = a13;
	a6 = a14;
	a7 = a15;
}

macro rollfwd12(){
	p0 = a0;
	p1 = a1;
	p2 = a2;
	p3 = a3;
	p4 = a4;
	p5 = a5;
	p6 = a6;
	p7 = a7;
	p8 = a8;
	p9 = a9;
	p10 = a10;
	p11 = a11;
	a0 = a12;
	a1 = a13;
	a2 = a14;
	a3 = a15;
} 

#127c -> -0xf
#1x7x -> -0xf
#001  111 

macro instr_top(){}

macro instr_bot(){}

imm7: imm is imm7_6_4 & imm7_3_0
[imm =  ((((imm7_6_4&0x4)>>2)&((imm7_6_4&0x2)>>1))*(0xFFFFFF80)) | (((imm7_6_4)<<4) | imm7_3_0);]{
	local tmp:4 = imm;
	export tmp;
}

rel12: loc
is simm12 [loc = inst_start + simm12 + 4;]{
	export *:4 loc;
}

rel16: loc 
is simm16 [loc = ((inst_start+3)&0xfffffffc) + (0xfffc0000|(simm16)<<2);] {
	export *:4 loc;
}

frameSize: loc 
is imm12 [loc=imm12<<3;]{ 
	local tmp:4 = loc; 
	export tmp; 
}

callRel: loc
is call_offset [loc = (inst_start&0xfffffffc) + (call_offset<<2) + 4;]
{
	export *:4 loc;
}


######################################################

:call8 callRel 
is op0=0x5 & val_n=0x2 & callRel{
	a8 = inst_next;
	rollfwd8();
	call callRel;
	rollback8();
}

:callx8 reg_s 
is val_m=0x3 & val_n=0x2 & op0=0 & r=0 & op1=0 & op2=0 & reg_s{
	local dst:4 = reg_s;
	a8 = inst_next;
	rollfwd8();
	call [dst];
	rollback8();
}

:entry reg_s, frameSize
is op0=0x6 & val_n=0x3 & val_m=0x0 & reg_s & frameSize {
	reg_s = reg_s - frameSize;
}

:retw.n 
is op16_whole=0xF01D {
	return [a0];
}

:l32r reg_t, rel16
is op0=0x1 & reg_t & rel16 {
	reg_t = rel16;
}

:mov.n reg_t_16, reg_s_16
is op0_16=0xd & r_16=0x0 & reg_t_16 & reg_s_16 {
	instr_top();
	reg_t_16 = reg_s_16;
	instr_bot();
} 

:movi.n reg_s_16, imm7
is op0_16=0xc & val_i=0 & reg_s_16 & imm7 {
	instr_top();
	reg_s_16 = imm7;
	instr_bot();
}

i32_offset: offst is imm4_16
[offst = (imm4_16 << 2);] 
{
	local tmp:4 = offst;
	export tmp;
}

:s32i.n reg_t_16, reg_s_16, i32_offset
is op0_16=0x9 & reg_s_16 & reg_t_16 & i32_offset{
	instr_top();
	local vAddr:4 = reg_s_16 + i32_offset;
	*:4 vAddr = reg_t_16;
	instr_bot();
}


:l32i.n reg_t_16, reg_s_16, i32_offset
is op0_16=0x8 & reg_s_16 & reg_t_16 & i32_offset{
	instr_top();
	local vAddr:4 = reg_s_16 + i32_offset;
	reg_t_16 = *:4 vAddr;
	instr_bot();
}

i32_offset_8: offst is imm8
[offst = (imm8 << 2);]{
	local tmp:4 = offst;
	export tmp;
}

:s32i reg_t, reg_s, i32_offset_8
is r=6 & op0=2 & reg_t & reg_s & i32_offset_8{
	instr_top();
	local vAddr:4 = reg_s + i32_offset_8;
	*:4 vAddr = reg_t;
	instr_bot();
}

:bnez reg_s, rel12
is op0=0x6 & val_n=0x1 & val_m=0x1 & reg_s & rel12{
	if(reg_s != 0) goto rel12;
}

:mov reg_r, reg_s
is op2=2 & op1=0 & op0=0 & reg_r & reg_s {
	instr_top();
	reg_r = reg_s;
	instr_bot();
}

imm12_split: imm is imm12_11_8 & imm12_7_0
[imm = (((imm12_11_8>>3)&1)*0xFFFFF000)|((imm12_11_8<<8)|imm12_7_0);]{
	local tmp:4 = imm;
	export tmp;
}

:movi reg_t, imm12_split 
is r=0xa & op0=0x2 & imm12_split & reg_t {
	instr_top();
	reg_t = imm12_split;
	instr_bot();
}

br_offst6: loc is imm6_5_4 & imm6_3_0 
[loc = inst_start + ((imm6_5_4<<4)|imm6_3_0) + 4;]
{
	export *:4 loc;
}

:bnez.n reg_s_16, br_offst6 
is op0_16=0xc & reg_s_16 & br_offst6 & val_i=1 & val_z=1 {
	if(reg_s_16 != 0) goto br_offst6;
}

br_offst_simm8: loc is simm8
[loc = inst_start + simm8 + 4;]
{
	export *:4 loc;
}

:beq reg_s, reg_t, br_offst_simm8
is op0=0x7 & r=0x1 & reg_s & reg_t & br_offst_simm8 {
	if(reg_s == reg_t) goto br_offst_simm8;
}

:add.n reg_r_16, reg_s_16, reg_t_16
is op0_16=0xa & reg_r_16 & reg_s_16 & reg_t_16 {
	instr_top();
	reg_r_16 = reg_s_16 + reg_t_16;
	instr_bot();
}


#TODO: fix up tlb accesses?
define pcodeop dtlb_write;
define pcodeop dtlb_read;
define pcodeop itlb_write;
define pcodeop itlb_read;
define pcodeop isync;
define pcodeop dsync;


:wdtlb reg_t, reg_s
is op0=0x0 & op1=0x0 & op2=0x5 & r=0xe & reg_t & reg_s {
	instr_top();
	dtlb_write(reg_s, reg_t);
	instr_bot();
}

:witlb reg_t, reg_s
is op0=0x0 & op1=0x0 & op2=0x5 & r=0x6 & reg_t & reg_s {
	instr_top();
	itlb_write(reg_s, reg_t);
	instr_bot();
}

:dsync 
is op0=0x0 & op1=0x0 & op2=0x0 & r=0x2 & t=0x3 & s=0x0 {
	dsync();
}

:isync
is op0=0x0 & op1=0x0 & op2=0x0 & r=0x2 & t=0x0 & s=0x0 {
	isync();
}

imm_4bit_converted: imm is t_16
[imm = (-1 * ( ((~t_16)&0x1) & (((~t_16)>>1)&0x1) & (((~t_16)>>2)&0x1) & (((~t_16)>>3)&0x1))) |
	(t_16  * (((t_16)&0x1) | ((t_16>>1)&0x1) | ((t_16>>2)&0x1) | ((t_16>>3)&0x1)));]
{
	local tmp:4 = imm;
	export tmp;
}

:addi.n reg_r_16, reg_s_16, imm_4bit_converted 
is op0_16=0xb & reg_r_16 & reg_s_16 & imm_4bit_converted {
	instr_top();
	reg_r_16 = reg_s_16 + imm_4bit_converted;
	instr_bot();
}

#TODO: replace wsr pcodeop
define pcodeop wsr;
:wsr  reg_t, sr 
is op0=0 & op1=0x3 & op2=0x1 & sr & reg_t {
	local tmp:4 = sr;
	wsr(reg_t, tmp);
}

#20 61 13
